% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/player_pagerank.R
\name{compute_cricket_pagerank}
\alias{compute_cricket_pagerank}
\title{Compute Cricket PageRank}
\usage{
compute_cricket_pagerank(
  matchup_matrix,
  performance_matrix,
  wicket_matrix = NULL,
  damping = PAGERANK_DAMPING,
  max_iter = PAGERANK_MAX_ITER,
  tolerance = PAGERANK_TOLERANCE,
  wicket_weight = PAGERANK_WICKET_WEIGHT,
  verbose = TRUE
)
}
\arguments{
\item{matchup_matrix}{Matrix of delivery counts (batter x bowler).}

\item{performance_matrix}{Matrix of normalized runs/ball (0-1 scale).}

\item{wicket_matrix}{Matrix of wicket proportions (0-1 scale). Optional.}

\item{damping}{Numeric. Damping factor (default from PAGERANK_DAMPING).}

\item{max_iter}{Integer. Maximum iterations (default from PAGERANK_MAX_ITER).}

\item{tolerance}{Numeric. Convergence threshold (default from PAGERANK_TOLERANCE).}

\item{wicket_weight}{Numeric. How much wickets contribute to bowler quality
(default from PAGERANK_WICKET_WEIGHT).}

\item{verbose}{Logical. Print progress messages. Default TRUE.}
}
\value{
List with:
\itemize{
\item batter_pagerank: Named vector of batter PageRank scores
\item bowler_pagerank: Named vector of bowler PageRank scores
\item iterations: Number of iterations until convergence
\item converged: Logical, whether algorithm converged
}
}
\description{
Computes PageRank-style quality scores for batters and bowlers using
an iterative algorithm on the bipartite matchup graph.
}
\details{
The algorithm alternates between updating batter and bowler scores:
\itemize{
\item Batter quality = weighted average of bowler quality faced, scaled by performance
\item Bowler quality = weighted average of batter quality restricted, scaled by economy
}
}
\keyword{internal}
